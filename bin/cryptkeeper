#!/usr/bin/env python
# -*- coding: UTF-8 -*-



"""

@authors: Jeffrey Barrick

Predict cryptic bacterial gene expression signals in an input sequence.

"""

import argparse
import Bio
from Bio.SeqIO import FastaIO
from Bio.Seq import Seq
from Bio.Alphabet import generic_dna
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
import subprocess
import csv
from operator import itemgetter
import os
import sys
from copy import deepcopy

import plotly
import plotly.graph_objs as go
import numpy


#------------------------------------------------------------------------------
parser = argparse.ArgumentParser(description='input fasta')
parser.add_argument(
    '-i', '--input',
    action='store',
    dest='i',
    required=True,
    type=str,
    help="input fasta file",
    )

parser.add_argument(
    '-c', '--circular',
    action='store_true',
    dest='circular',
    help="The input file is circular. (Note: Increases runtime by 3x)",
    )

parser.add_argument(
    '-o', '--output',
    action='store',
    dest='o',
    required=True,
    type=str,
    help="output file prefix",
    )

parser.add_argument(
    '-p', '--plot-only',
    action='store_true',
    dest='plot_only',
    help="plot mode, assumes output files all exist",
    )

parser.add_argument(
    '-n', '--name',
    action='store',
    dest='name',
    help="name of sample (if not provided the filename is used)",
    )

parser.add_argument(
    '--rbs-score-cutoff',
    action='store',
    dest='rbs_score_cutoff',
    default=2.0,
    type=float,
    help="Minimum score that is graphed and output to final files (all are used in calculating burden)",
    )

parser.add_argument(
    '-w', '--web',
    action='store_true',
    dest='web',
    help="web mode. Writes output as a div without including javascript to file *.div instead of normal *.html",
    )

#parser.add_argument(
#    '--pdf',
#    action='store_true',
#    dest='pdf',
#    help="write output plot as *.pdf",
#    )

#------------------------------------------------------------------------------

options = parser.parse_args()

input_fasta_file_name = options.i

output_circular_fasta_file_name = options.o + '.circular.3x.fasta'

###### CIRCULAR SEQUENCE ######
# create a 3x version of the FASTA input file
i = 0
for this_seq in SeqIO.parse(options.i, "fasta"):
  i += 1
  if (i>1):
    print("FASTA contains multiple sequences. Only the first will be processed.")
    break
  sequence_length = len(this_seq)
  if (options.circular):
    with open(output_circular_fasta_file_name, "w") as output_handle:
      this_seq.seq = this_seq.seq + this_seq.seq + this_seq.seq
      SeqIO.write([this_seq], output_handle, "fasta")
      input_fasta_file_name = output_circular_fasta_file_name


# Predict promoters
tss_prediction_file_name = options.o + '.TSS.csv'

if not options.plot_only:
  tss_command = 'TSS_predict_BPROM.py -i ' + input_fasta_file_name + ' -o ' + tss_prediction_file_name
  print(tss_command)
  try:
    subprocess.check_call([tss_command], shell=True)
  except subprocess.CalledProcessError as e:
    print(e)
  except OSError as e:
    print(e)

# Create a gene annotation file
gene_annotation_file_name = options.o + '.gene.csv'

##=> to be implemented to read if input is genbank or GFF

# Predict terminators
rit_prediction_file_name = options.o + '.RIT.csv'

if not options.plot_only:
  rit_command = 'RIT_predict_TransTerm.py -i ' + input_fasta_file_name + ' -o ' + rit_prediction_file_name
  print(rit_command)
  try:
    subprocess.check_call([rit_command], shell=True)
  except subprocess.CalledProcessError as e:
    print(e)

# Predict ORFs

orf_prediction_file_name = options.o + '.ORF.csv'

if not options.plot_only:
  orf_command = 'ORF_predict.py -i ' + input_fasta_file_name + ' -o ' + orf_prediction_file_name
  print(orf_command)
  try:
    subprocess.check_call(orf_command, shell=True)
  except subprocess.CalledProcessError as e:
    print(e)
  except OSError as e:
    print(e)

# Predict RBS
rbs_prediction_file_name = options.o + '.RBS.csv'

if not options.plot_only:
  rbs_command = 'RBS_predict_RBS_Calculator.py -i ' + input_fasta_file_name + ' -o ' + rbs_prediction_file_name + ' -s ' + orf_prediction_file_name
  print(rbs_command)
  try:
    subprocess.check_call(rbs_command, shell=True)
  except subprocess.CalledProcessError as e:
    print(e)
  except OSError as e:
    print(e)

# Load sequence
i=0
main_seq = None
for this_seq in SeqIO.parse(options.i, "fasta"):
  i += 1
  if (i>1):
    exit()
  main_seq = this_seq.upper()

# Load predictions

tss_predictions = []
if (os.path.isfile(tss_prediction_file_name)):
  tss_reader = csv.DictReader(open(tss_prediction_file_name))
  for row in tss_reader:
    tss_predictions.append(row)

rit_predictions = []
if (os.path.isfile(rit_prediction_file_name)):
  rit_reader = csv.DictReader(open(rit_prediction_file_name))
  for row in rit_reader:
    rit_predictions.append(row)

orf_predictions = []
if (os.path.isfile(orf_prediction_file_name)):
  orf_reader = csv.DictReader(open(orf_prediction_file_name))
  for row in orf_reader:
    row['start_codon_position'] = int(row['start'] if row['strand'] == '+' else row['end'])
    if row['strand'] == '+':
      row['array_minus'] = 0
      row['array'] = int(row['end']) - int(row['start']) + 1
    else:
      row['array_minus'] = int(row['end']) - int(row['start']) + 1
      row['array'] = 0
    orf_predictions.append(row)

#Re-sort by the start codon position so we are in the same order as RBS
orf_predictions = sorted(orf_predictions, key=itemgetter('start_codon_position'))

#Combine ORF and RBS predictions AND calculate the crypt score
rbs_predictions = []
rbs_reader = csv.DictReader(open(rbs_prediction_file_name))
for row in rbs_reader:
  row["score"] = numpy.log10(float(row["score"]))
  rbs_predictions.append(row)


total_burden = 0

summary_file_name = options.o + '.summary.txt'
summary_file = open(summary_file_name, 'w')

#transfer information from orfs before we filter
for i in range(len(rbs_predictions)):

  rbs_predictions[i]['array'] = orf_predictions[i]['array']
  rbs_predictions[i]['array_minus'] = orf_predictions[i]['array_minus']

  orf_start = int(orf_predictions[i]['start'])
  orf_end = int(orf_predictions[i]['end'])
  orf_length = orf_end - orf_start + 1
  rbs_score = 10**float(rbs_predictions[i]['score'])
  rbs_predictions[i]['burden'] = orf_length * rbs_score

  # Add information to the orf as well
  orf_predictions[i]['rbs_score'] = rbs_predictions[i]['score']
  orf_predictions[i]['second_half'] = 'T'

  ###### CIRCULAR SEQUENCE ######
  # We need to only add if we are in the second copy,
  # between sequence_length + 1 and 2 * sequence_length

  add_to_score = True
  if (options.circular):
    if (orf_start <= sequence_length) or (orf_start >= sequence_length * 2 + 1):
      add_to_score = False

  if (add_to_score):
    total_burden = total_burden + rbs_predictions[i]['burden']
    summary_file.write("  " + str(orf_predictions[i]['start_codon_position']) + " Burden: " + str(rbs_predictions[i]['burden']) + "[ RBS Score: " + str(rbs_score) + " + ORF Length: " + str(orf_length) + " ]\n")

summary_file.write("Total Burden: " + str(total_burden))


# Filter predictions that we show
rbs_predictions = list(filter(lambda x:float(x["score"]) > options.rbs_score_cutoff, rbs_predictions))


#reload the gene annotation files
gene_annotations = []
if os.path.isfile(gene_annotation_file_name):
  gene_reader = csv.DictReader(open(gene_annotation_file_name))
  for row in gene_reader:
    row['position'] = row['end'] if row['strand'] == '+' else row['start']
    row['array'] = 0 if row['strand'] == '+' else int(row['end']) - int(row['start'])
    row['array_minus'] = int(row['end']) - int(row['start']) if row['strand'] == '+' else 0
    gene_annotations.append(row)




###### CIRCULAR SEQUENCE ######

if options.circular:

  # Remove ones with out of bounds starts/ends/positions (whichever is graphed)
  orf_predictions = list(filter(lambda x:(int(x['start']) >= sequence_length + 1)  and (int(x['start']) <= sequence_length * 2), orf_predictions))
  rbs_predictions = list(filter(lambda x:(int(x['position']) >= sequence_length + 1)  and (int(x['position']) <= sequence_length * 2), rbs_predictions))
  tss_predictions = list(filter(lambda x:(int(x['TSSpos']) >= sequence_length + 1)  and (int(x['TSSpos']) <= sequence_length * 2), tss_predictions))
  rit_predictions = list(filter(lambda x:(int(x['end']) >= sequence_length + 1)  and (int(x['end']) <= sequence_length * 2), rit_predictions))

  # Correct coordinates of remaining

  for d in rbs_predictions:
    d['position'] = str(int(d['position']) - sequence_length)

  for d in tss_predictions:
    d['TSSpos'] = str(int(d['TSSpos']) - sequence_length)

  for d in rit_predictions:
    d['end'] = str(int(d['end']) - sequence_length)

  # Split reading frames and assign
  added_split_orfs = []
  for d in orf_predictions:
    d['start'] = str(int(d['start']) - sequence_length)
    d['end'] = str(int(d['end']) - sequence_length)

    if (int(d['end']) > sequence_length):

      new_split_orf = deepcopy(d)
      d['end'] = str(sequence_length)
      new_split_orf['start'] = "1"
      new_split_orf['end'] = str(int(new_split_orf['end']) - sequence_length)

      if (d['strand'] != '+'):
        d['second_half'] = 'T'
      else:
        new_split_orf['second_half'] = 'T'

      added_split_orfs.append(new_split_orf)
  orf_predictions.extend(added_split_orfs)

# Print out entire changed lists - for graphing outside of this program in R, etc.
with open(options.o + ".final.ORF.csv",'w') as final_orf_predictions_file:
  writer = csv.DictWriter(
      final_orf_predictions_file,
      fieldnames = ["start", "end", "strand", "start_codon", 'length', 'rbs_score', 'array', 'array_minus', 'start_codon_position', 'second_half']
    )
  writer.writeheader()
  writer.writerows(orf_predictions)
final_orf_predictions_file.close()

with open(options.o + ".final.RBS.csv",'w') as final_rbs_predictions_file:
  writer = csv.DictWriter(
      final_rbs_predictions_file,
      fieldnames = ["position", "strand", "start_codon", "score", "score2", "burden", "array", "array_minus"]
    )
  writer.writeheader()
  writer.writerows(rbs_predictions)
final_rbs_predictions_file.close()



# Display predictions

#settings
TSS_color = '#2ab717'
RIT_color = '#ff0000'
RBS_color = '#0d30e0'
gene_color = '#000000'
gene_text_color = '#FFFFFF'
marker_size = 20
tss_score_max = 25

tss_series = go.Scatter(
  x = [d['TSSpos'] for d in tss_predictions],
  y = [d['score'] for d in tss_predictions],
  mode = 'markers',
  name = 'TSS',
  text = [ ('-35: ' + d['box35seq'] + "<br>" + '-10: ' + d['box10seq'])  for d in tss_predictions],

  marker = dict(
    symbol=[ ('triangle-right'  if d['strand'] == '+' else 'triangle-left')  for d in tss_predictions],
    size=marker_size,
    color=TSS_color,
  ),

  error_y=dict(
            type='data',
            array=[0],
            arrayminus=[d['score'] for d in tss_predictions],
            width=0,
            color=TSS_color,
        )
)

rit_series = go.Scatter(
  x = [e['end'] for e in rit_predictions],
  y = [e['conf'] for e in rit_predictions],
  mode = 'markers',
  name = 'RIT',
  text = [ ('hairpin score:' + d['hairpin_score'] + '; tail score:' + d['tail_score'] + '<br>' + d['seq_hairpin_open'] + '-' + d['seq_hairpin_loop'] + '-' + d['seq_hairpin_close'] + '-' + d['seq_tail'][0:7] )  for d in rit_predictions],
  yaxis='y2',
  marker = dict(
    symbol=[ ('triangle-right'  if d['strand'] == '+' else 'triangle-left')  for d in rit_predictions],
    size=marker_size,
    color=RIT_color,
  ),
  error_y=dict(
          type='data',
          array=[0],
          arrayminus=[e['conf'] for e in rit_predictions],
          width=0,
          color=RIT_color,
      )
)

rbs_series = go.Scatter(
  x = [f['position'] for f in rbs_predictions],
  y = [f['score'] for f in rbs_predictions],
  mode = 'markers',
  text = [ ('start codon:' + d['start_codon'] + "<br>Burden ×10<sup>6</sup>: " + "{0:.6f}".format(d['burden']/1000000) + " (" + "{0:.2f}".format(100*d['burden']/total_burden) + "%}")  for d in rbs_predictions],
  name = 'RBS',
  yaxis='y3',
  marker = dict(
    symbol=[ ('triangle-right'  if d['strand'] == '+' else 'triangle-left')  for d in rbs_predictions],
    size=marker_size,
    color=RBS_color,
  ),
  error_y=dict(
          type='data',
          array=[0],
          arrayminus=[f['score'] for f in rbs_predictions],
          width=0,
          color=RBS_color,
  ),
  error_x=dict(
          type='data',
          array=[f['array'] for f in rbs_predictions],
          arrayminus=[f['array_minus'] for f in rbs_predictions],
          width=3,
          color=RBS_color,
  ),
)

nucleotide_sequence  = go.Scatter(
  x=list(range(0,len(main_seq)-1)),
  y=[0.97]*len(main_seq),
  mode='text',
  name = 'Sequence',
  text=list(main_seq.seq),
  yaxis='y4',
)

gene_series  = go.Scatter(
  x=[f['position'] for f in gene_annotations],
  y=[0.93]*len(gene_annotations),
  mode='markers+text',
  text=[ d['gene'] for d in gene_annotations ],
  name = 'Gene',
  yaxis='y4',
  marker = dict(
  symbol=[ ('triangle-right'  if d['strand'] == '+' else 'triangle-left') for d in gene_annotations],
    size=marker_size,
    color=gene_color,
    ),
  error_x=dict(
          type='data',
          array=[f['array'] for f in gene_annotations],
          arrayminus=[f['array_minus'] for f in gene_annotations],
          thickness=10,
          width=0,
          color=gene_color,
  ),
)


## Use display name at command line if it was given, otherwise file name
if options.name:
  display_name = options.name
else:
  display_name = input_fasta_file_name

layout = go.Layout(
  title='CryptKeeper Results: ' + display_name + "  Burden ×10<sup>6</sup>: " + "{0:.2f}".format(total_burden/1000000),
  hovermode = 'closest',
  autosize=True,

  xaxis=dict(
        domain=[0.20, 1.0]
  ),
  yaxis=dict(
    title='TSS score',
    range = [0, tss_score_max+0.2],
    titlefont=dict(
        color=TSS_color
    ),
    tickfont=dict(
        color=TSS_color
    )
  ),
  yaxis2=dict(
      title='RIT score',
      range = [0, 110],
      titlefont=dict(
          color=RIT_color
      ),
      tickfont=dict(
          color=RIT_color
      ),
      anchor='free',
      overlaying='y',
      side='left',
      position=0.10,
  ),
  yaxis3=dict(
      title='log10 RBS score',
      range = [2, 6],
      titlefont=dict(
          color=RBS_color
      ),
      tickfont=dict(
          color=RBS_color
      ),
      anchor='free',
      overlaying='y',
      side='left',
      position=0.15,
  ),
  yaxis4=dict(
      title='sequence',
      range = [0, 1],
      titlefont=dict(
          color='black'
      ),
      tickfont=dict(
          color='black'
      ),
      anchor='free',
      overlaying='y',
      side='left',
      position=0.05,
  ),
)

data = [tss_series, rit_series, rbs_series, nucleotide_sequence, gene_series]

fig = dict( data=data, layout=layout )

#if (options.pdf):
#  fig.write_image(options.o+'.pdf')
if (options.web):
  dev_content = plotly.offline.plot(fig, include_plotlyjs=False, output_type='div')
  f = open(options.o+'.plot.div', 'w')
  f.write(dev_content)
  f.close()
else:
  plotly.offline.plot(fig, filename=options.o+'.plot.html')
