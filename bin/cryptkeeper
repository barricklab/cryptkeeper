#!/usr/bin/env python
# -*- coding: UTF-8 -*-



"""

@authors: Jeffrey Barrick

Predict cryptic bacterial gene expression signals in an input sequence.

"""

import argparse
import Bio
from Bio.SeqIO import FastaIO
from Bio.Seq import Seq
from Bio.Alphabet import generic_dna
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
import subprocess
import csv
from operator import itemgetter
import os

import plotly
import plotly.graph_objs as go
import numpy


#------------------------------------------------------------------------------
parser = argparse.ArgumentParser(description='input fasta')
parser.add_argument(
    '-i',
    action='store',
    dest='i',
    required=True,
    type=str,
    help="input fasta file",
    )

parser.add_argument(
    '-o',
    action='store',
    dest='o',
    required=True,
    type=str,
    help="output file prefix",
    )

parser.add_argument(
    '-p',
    action='store_true',
    dest='plot_only',
    help="plot mode, assumes output files all exist",
    )

parser.add_argument(
    '-n',
    action='store',
    dest='name',
    help="name of sample(if not present filename is used)",
    )

parser.add_argument(
    '-w',
    action='store_true',
    dest='web',
    help="Web mode. Writes output as a div without including javascript to file *.div instead of normal *.html",
    )

#------------------------------------------------------------------------------

options = parser.parse_args()

input_fasta_file_name = options.i

# Predict promoters
tss_prediction_file_name = options.o + '.TSS.csv'

if not options.plot_only:
  tss_command = 'TSS_predict_BPROM.py -i ' + input_fasta_file_name + ' -o ' + tss_prediction_file_name
  print(tss_command)
  try:
    subprocess.check_call([tss_command], shell=True)
  except subprocess.CalledProcessError as e:
    print(e)
  except OSError as e:
    print(e)

# Create a gene annotation file
gene_annotation_file_name = options.o + '.gene.csv'

##=> to be implemented to read if input is genbank or GFF

# Predict terminators
rit_prediction_file_name = options.o + '.RIT.csv'

if not options.plot_only:
  rit_command = 'RIT_predict_TransTerm.py -i ' + input_fasta_file_name + ' -o ' + rit_prediction_file_name
  print(rit_command)
  try:
    subprocess.check_call([rit_command], shell=True)
  except subprocess.CalledProcessError as e:
    print(e)

# Predict ORFs

orf_prediction_file_name = options.o + '.ORF.csv'

if not options.plot_only:
  orf_command = 'ORF_predict.py -i ' + input_fasta_file_name + ' -o ' + orf_prediction_file_name
  print(orf_command)
  try:
    subprocess.check_call(orf_command, shell=True)
  except subprocess.CalledProcessError as e:
    print(e)
  except OSError as e:
    print(e)

# Predict RBS
rbs_prediction_file_name = options.o + '.RBS.csv'

if not options.plot_only:
  rbs_command = 'RBS_predict_RBS_Calculator.py -i ' + input_fasta_file_name + ' -o ' + rbs_prediction_file_name + ' -s ' + orf_prediction_file_name
  print(rbs_command)
  try:
    subprocess.check_call(rbs_command, shell=True)
  except subprocess.CalledProcessError as e:
    print(e)
  except OSError as e:
    print(e)

# Load sequence
i=0
main_seq = None
for this_seq in SeqIO.parse(options.i, "fasta"):
  i += 1
  if (i>1):
    exit()
  main_seq = this_seq.upper()

# Load predictions

tss_predictions = []
if (os.path.isfile(tss_prediction_file_name)):
  tss_reader = csv.DictReader(open(tss_prediction_file_name))
  for row in tss_reader:
    tss_predictions.append(row)

rit_predictions = []
if (os.path.isfile(rit_prediction_file_name)):
  rit_reader = csv.DictReader(open(rit_prediction_file_name))
  for row in rit_reader:
    rit_predictions.append(row)

orf_predictions = []
if (os.path.isfile(orf_prediction_file_name)):
  orf_reader = csv.DictReader(open(orf_prediction_file_name))
  for row in orf_reader:
    row['start_codon_position'] = int(row['start'] if row['strand'] == '+' else row['end'])
    if row['strand'] == '+':
      row['array_minus'] = 0
      row['array'] = int(row['end']) - int(row['start']) + 1
    else:
      row['array_minus'] = int(row['end']) - int(row['start']) + 1
      row['array'] = 0
    orf_predictions.append(row)

#Re-sort by the start codon position so we are in the same order as RBS
orf_predictions = sorted(orf_predictions, key=itemgetter('start_codon_position'))

#Combine ORF and RBS predictions AND calculate the crypt score
rbs_predictions = []
rbs_reader = csv.DictReader(open(rbs_prediction_file_name))
for row in rbs_reader:
  row["score"] = numpy.log10(float(row["score"]))
  rbs_predictions.append(row)


total_burden = 0

summary_file_name = options.o + '.summary.txt'
summary_file = open(summary_file_name, 'w')

#transfer information from orfs before we filter
for i in range(len(rbs_predictions)):

  rbs_predictions[i]['array'] = orf_predictions[i]['array']
  rbs_predictions[i]['array_minus'] = orf_predictions[i]['array_minus']

  orf_length = (int(orf_predictions[i]['end']) - int(orf_predictions[i]['start']) + 1)
  rbs_score = 10**float(rbs_predictions[i]['score'])
  rbs_predictions[i]['burden'] = orf_length * rbs_score

  total_burden = total_burden + rbs_predictions[i]['burden']
  summary_file.write("  " + str(orf_predictions[i]['start_codon_position']) + " Burden: " + str(rbs_predictions[i]['burden']) + "[ RBS Score: " + str(rbs_score) + " + ORF Length: " + str(orf_length) + " ]\n")

summary_file.write("Total Burden: " + str(total_burden))



# Filter predictions
rbs_predictions = list(filter(lambda x:float(x["score"]) > 1, rbs_predictions))


#reload the gene annotation files
gene_annotations = []
if os.path.isfile(gene_annotation_file_name):
  gene_reader = csv.DictReader(open(gene_annotation_file_name))
  for row in gene_reader:
    row['position'] = row['end'] if row['strand'] == '+' else row['start']
    row['array'] = 0 if row['strand'] == '+' else int(row['end']) - int(row['start'])
    row['array_minus'] = int(row['end']) - int(row['start']) if row['strand'] == '+' else 0
    gene_annotations.append(row)


# Display predictions

#settings
TSS_color = '#2ab717'
RIT_color = '#ff0000'
RBS_color = '#0d30e0'
gene_color = '#000000'
gene_text_color = '#FFFFFF'
marker_size = 20
tss_score_max = 10

tss_series = go.Scatter(
  x = [d['TSSpos'] for d in tss_predictions],
  y = [d['score'] for d in tss_predictions],
  mode = 'markers',
  name = 'TSS',
  text = [ ('-35: ' + d['box35seq'] + "<br>" + '-10: ' + d['box10seq'])  for d in tss_predictions],

  marker = dict(
    symbol=[ ('triangle-right'  if d['strand'] == '+' else 'triangle-left')  for d in tss_predictions],
    size=marker_size,
    color=TSS_color,
  ),

  error_y=dict(
            type='data',
            array=[0],
            arrayminus=[d['score'] for d in tss_predictions],
            width=0,
            color=TSS_color,
        )
)

rit_series = go.Scatter(
  x = [e['end'] for e in rit_predictions],
  y = [e['conf'] for e in rit_predictions],
  mode = 'markers',
  name = 'RIT',
  text = [ ('hairpin score:' + d['hairpin_score'] + '; tail score:' + d['tail_score'] + '<br>' + d['seq_hairpin_open'] + '-' + d['seq_hairpin_loop'] + '-' + d['seq_hairpin_close'] + '-' + d['seq_tail'][0:7] )  for d in rit_predictions],
  yaxis='y2',
  marker = dict(
    symbol=[ ('triangle-right'  if d['strand'] == '+' else 'triangle-left')  for d in rit_predictions],
    size=marker_size,
    color=RIT_color,
  ),
  error_y=dict(
          type='data',
          array=[0],
          arrayminus=[e['conf'] for e in rit_predictions],
          width=0,
          color=RIT_color,
      )
)

rbs_series = go.Scatter(
  x = [f['position'] for f in rbs_predictions],
  y = [f['score'] for f in rbs_predictions],
  mode = 'markers',
  text = [ ('start codon:' + d['start_codon'] + "<br>Burden ×10<sup>6</sup>: " + "{0:.6f}".format(d['burden']/1000000) + " (" + "{0:.2f}".format(100*d['burden']/total_burden) + "%}")  for d in rbs_predictions],
  name = 'RBS',
  yaxis='y3',
  marker = dict(
    symbol=[ ('triangle-right'  if d['strand'] == '+' else 'triangle-left')  for d in rbs_predictions],
    size=marker_size,
    color=RBS_color,
  ),
  error_y=dict(
          type='data',
          array=[0],
          arrayminus=[f['score'] for f in rbs_predictions],
          width=0,
          color=RBS_color,
  ),
  error_x=dict(
          type='data',
          array=[f['array'] for f in rbs_predictions],
          arrayminus=[f['array_minus'] for f in rbs_predictions],
          width=3,
          color=RBS_color,
  ),
)

nucleotide_sequence  = go.Scatter(
  x=list(range(0,len(main_seq)-1)),
  y=[0.97]*len(main_seq),
  mode='text',
  name = 'Sequence',
  text=list(main_seq.seq),
  yaxis='y4',
)

gene_series  = go.Scatter(
  x=[f['position'] for f in gene_annotations],
  y=[0.93]*len(gene_annotations),
  mode='markers+text',
  text=[ d['gene'] for d in gene_annotations ],
  name = 'Gene',
  yaxis='y4',
  marker = dict(
  symbol=[ ('triangle-right'  if d['strand'] == '+' else 'triangle-left') for d in gene_annotations],
    size=marker_size,
    color=gene_color,
    ),
  error_x=dict(
          type='data',
          array=[f['array'] for f in gene_annotations],
          arrayminus=[f['array_minus'] for f in gene_annotations],
          thickness=10,
          width=0,
          color=gene_color,
  ),
)


## Use display name at command line if it was given, otherwise file name
if options.name:
  display_name = options.name
else:
  display_name = input_fasta_file_name

layout = go.Layout(
  title='CryptKeeper Results: ' + display_name + "  Burden ×10<sup>6</sup>: " + "{0:.2f}".format(total_burden/1000000),
  hovermode = 'closest',
  autosize=True,

  xaxis=dict(
        domain=[0.20, 1.0]
  ),
  yaxis=dict(
    title='TSS score',
    range = [0, tss_score_max+0.2],
    titlefont=dict(
        color=TSS_color
    ),
    tickfont=dict(
        color=TSS_color
    )
  ),
  yaxis2=dict(
      title='RIT score',
      range = [0, 110],
      titlefont=dict(
          color=RIT_color
      ),
      tickfont=dict(
          color=RIT_color
      ),
      anchor='free',
      overlaying='y',
      side='left',
      position=0.10,
  ),
  yaxis3=dict(
      title='log10 RBS score',
      range = [1, 5],
      titlefont=dict(
          color=RBS_color
      ),
      tickfont=dict(
          color=RBS_color
      ),
      anchor='free',
      overlaying='y',
      side='left',
      position=0.15,
  ),
  yaxis4=dict(
      title='sequence',
      range = [0, 1],
      titlefont=dict(
          color='black'
      ),
      tickfont=dict(
          color='black'
      ),
      anchor='free',
      overlaying='y',
      side='left',
      position=0.05,
  ),
)

data = [tss_series, rit_series, rbs_series, nucleotide_sequence, gene_series]

fig = dict( data=data, layout=layout )

if (options.web):
  dev_content = plotly.offline.plot(fig, include_plotlyjs=False, output_type='div')
  f = open(options.o+'.plot.div', 'w')
  f.write(dev_content)
  f.close()
else:
  plotly.offline.plot(fig, filename=options.o+'.plot.html')
